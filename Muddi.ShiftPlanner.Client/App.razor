@using Muddi.ShiftPlanner.Client.Pages
@implements IDisposable


<Router AppAssembly="@typeof(App).Assembly" NotFoundPage="typeof(NotFoundPage)">
	<Found Context="routeData">
		@if (ShowContent)
		{
			<AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
				<NotAuthorized>
					@if (context.User.Identity?.IsAuthenticated != true)
					{
						<RedirectToLogin/>
					}
					else
					{
						<p role="alert">Du hast keine Erlaubnis diese Resource zu sehen.</p>
					}
				</NotAuthorized>
				<Authorizing>
					<LoadingSpinner/>
				</Authorizing>
			</AuthorizeRouteView>
		}
		else
		{
			<div class="muddi-plain-content mt-5">
				<LoadingSpinner/>
				<h1 style="color: var(--main-primary)">NEUE VERSION!</h1>
				<p>Eine neue Version wurde gefunden. Sie wird aktualisiert...</p>
			</div>
		}
	</Found>
</Router>

@code {

	// ReSharper disable once AutoPropertyCanBeMadeGetOnly.Local
	// We need it for release mode
	private bool ShowContent { get; set; } = true;

#if RELEASE
	[Inject] public required Toolbelt.Blazor.PWA.Updater.Service.IPWAUpdaterService PwaUpdaterService { get; set; }
	[Inject] public required DialogService DialogService { get; set; }

	protected override void OnAfterRender(bool firstRender)
	{
		if (firstRender)
		{
			PwaUpdaterService.NextVersionIsWaiting += PWAUpdaterService_NextVersionIsWaiting;
		}
	}

	private async void PWAUpdaterService_NextVersionIsWaiting(object? sender, EventArgs e)
	{
		ShowContent = false;
		_ = InvokeAsync(StateHasChanged);
		await Task.Delay(1000);
		await PwaUpdaterService.SkipWaitingAsync();
	}

	public void Dispose()
	{
		PwaUpdaterService.NextVersionIsWaiting -= PWAUpdaterService_NextVersionIsWaiting;
	}

#else

	public void Dispose()
	{
		//Empty
	}

#endif
}